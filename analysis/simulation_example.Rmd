---
title: "Simulation Example"
author: "Weijia Qian"
date: "2025-12-30"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(here)
library(MASS)
library(refund)
library(splines)
library(tidyverse)

# source(here("source", "gibbs_2.R"))

load(here("data", "dat_func.Rdata")) # real data

# set.seed(42)
```

```{r simulate data}
source(here("source", "simulate_AFT.R"))

sim_data <- simulate_AFT(family = "lognormal",  # "lognormal" or "loglogistic"
                         n_cluster = 200,       # number of clusters
                         n_subject = 10,        # number of subjects per cluster
                         nS = 100,              # density of s grid
                         k0 = 20,
                         alpha = 0,
                         beta_type = "peak2",    # "monotone"/"peak1"/"peak2"/"wavy"
                         gamma = c(0.5, 0.3, -0.2),  # c(intercept, gamma1, gamma2)
                         tau = 1,               # SD of random noise
                         sigma = 1,             # SD of frailty term
                         censor_rate = 0.1      
                         )
mean(sim_data$data$delta)
summary(sim_data$data$Y)
```

```{r gibbs sampler}
# extract elements from simulated data
data <- sim_data$data
s_grid = sim_data$coefficients$time
Z <- model.matrix(~ Z1 + Z2, data = data)
W <- data$W

# numerical rank
sv <- svd(data$W)$d
# plot(sv / max(sv), log="y", type="b")
tol <- max(dim(data$W)) * .Machine$double.eps * max(sv)
rank <- sum(sv > tol)
rank

# entropy effective rank
p <- sv / sum(sv)
rank_eff <- exp(-sum(p * log(p)))
rank_eff
```


```{r gibbs sampler}
source(here("source", "gibbs.R"))

# run Gibbs sampler
fit <- gibbs_functional_frailty(
  time = data$Y,         # survival time
  status = data$delta,   # event status
  cluster_id = data$cluster_id,
  Z = Z,                 # scalar covariate matrix
  X = data$X,            # functional covariate matrix
  s_grid = s_grid,
  # tuning / priors
  K = 20,                # df of B-splines
  # lambda = 100,
  lambda_init = 100,         # smoothing parameter
  A_lambda = 1, B_lambda = 0.001, # gamma(A,B) for lambda
  var_gamma = 100,       # variance for gamma prior (N(0, var_gamma I))
  A_tau2 = 3, B_tau2 = 2,  # IG(A,B) for tau^2 (shape A, scale B)
  A_sigma2 = 3, B_sigma2 = 2,  # IG(A,B) for sigma^2 (shape A, scale B)
  # MCMC
  n_iter = 20000,
  n_burn = 10000,
  n_thin = 1,
  verbose = TRUE
)
```

```{r posterior summaries}
# gamma
print(apply(fit$gamma, 2, quantile, probs = c(0.025, 0.5, 0.975)))

# tau^2, sigma^2
quantile(fit$tau2,   c(0.025, 0.5, 0.975))
quantile(fit$sigma2, c(0.025, 0.5, 0.975))
# bias of sigma^2
mean(fit$sigma2) - sim_data$coefficients$sigma[1]^2

# beta(s)
y_all <- c(
  fit$beta_mean,
  fit$beta_q025,
  fit$beta_q975,
  sim_data$coefficients$beta
)

ylim <- range(y_all)
pad  <- 0.1 * diff(ylim)
ylim <- ylim + c(-pad, pad)

plot(x = s_grid, y = fit$beta_mean, type="l", xlab="s", ylab= expression(beta(s)), 
     ylim = ylim,
     # main="Monotone (K = 6)",
     lwd = 2
     )
lines(x = s_grid, y = fit$beta_q025, lty = 2)
lines(x = s_grid, y = fit$beta_q975, lty = 2)
# lines(x = s_grid, y = fit$beta_cma_lower, lty=3)
# lines(x = s_grid, y = fit$beta_cma_upper, lty=3)
lines(x = s_grid,  y = sim_data$coefficients$beta, col = "red", lwd = 2)
legend(
  "topleft",
  legend = c("Posterior mean", "Pointwise 95% CI", "CMA 95% CI", "True beta(s)"),
  lty = c(1, 2, 3, 1),
  lwd = c(2, 1, 1, 2),
  col = c("black", "black", "black", "red"),
  bty = "n"
)

# frailty term u
u_mean <- colMeans(fit$u)
u_true <- sim_data$u
u_bias <- u_mean - u_true
plot(u_mean, u_true)
abline(a=0, b=1, col='red')

mean(fit$lambda)

```

```{r diagnostics}
# trace plots
par(mfrow=c(2,2))
plot(fit$tau2,   type="l", main="tau2",   ylab="", xlab="iter")
abline(h = (sim_data$coefficients$tau)^2, lwd = 2, col = "red")
plot(fit$sigma2, type="l", main="sigma2", ylab="", xlab="iter")
abline(h = (sim_data$coefficients$sigma)^2, lwd = 2, col = "red")
plot(fit$gamma[, "Z1"], type="l", main="gamma_Z1", ylab="", xlab="iter")
abline(h = sim_data$coefficients$gamma[1,2], lwd = 2, col = "red")
plot(fit$gamma[, "Z2"], type="l", main="gamma_Z2", ylab="", xlab="iter")
abline(h = sim_data$coefficients$gamma[1,3], lwd = 2, col = "red")
plot(fit$lambda, type="l", main="lambda", ylab="", xlab="iter")
# autocorrelation + effective sample size (ESS)
# library(coda)
# mcmc_sigma2 <- mcmc(fit$sigma2)
# acf(mcmc_sigma2)                 # autocorrelation plot
# effectiveSize(mcmc_sigma2)  
```
```{r}
table_sigma_bias <- all_coef %>%
  group_by(beta_type, sigma) %>%
  summarise(mean_sigma2_bias = round(mean(sigma2_bias),3))
```

